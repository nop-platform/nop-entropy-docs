Nop Platform 2.0是基于可逆计算理论从零开始构建的下一代低代码开发平台，它从理论层面超越了传统的组件技术和模型驱动架构，可以有效的解决粗粒度软件复用的问题，克服低代码平台扩展性差、性能低，且只能应用于少数成熟领域的限制。

Nop平台采用面向语言编程范式（Language Oriented Programming），在应用开发时并不是直接使用通用程序语言（如Java、C#）来开发，而是先定义一个领域特定语言（DSL），然后再应用DSL来表达业务。Nop平台的设计目标是成为简单易用的领域语言工作台（Domain Language Workbench） 。通过增加简单的元数据定义，就可以自动得到对应的DSL解析器、验证器、IDE插件、调试工具等，并自动为DSL领域语言增加模块分解、差量定制、元编程等通用语言特性。在这一点上，它类似于Jetbrains公司的MPS产品 ，只是它的设计原理和技术实现路径与MPS有着本质性差别。

传统的组件技术只能复用A和B之间的公共部分，导致复用的粒度一定是比A和B都要小的，在理论层面就无法实现一个复杂的完整系统的复用。可逆计算理论明确指出了逆元概念在软件构造领域的重要性，并结合产生式编程（Generative Programming），提出了一个系统化的实现粗粒度软件复用的技术路线

> `App = Delta x-extends Generator<DSL>`

可逆计算将复用的基本原理从相同可复用拓展到了相关可复用，在软件世界中引入了新的软件构造原理，可以用通用的方式解决此前的技术所不可能解决的软件复用问题。业内最新的一些基于差量概念的创新实践，如Docker和K8s中的kustomize技术等，都可以在可逆计算理论的框架下得到统一的理论解释，详细介绍参见[可逆计算：下一代软件构造理论](https://zhuanlan.zhihu.com/p/64004026)。

Nop平台是可逆计算理论的一个具体实现。

1. nop-entropy是Nop平台的后端部分。它采用Java语言实现，不依赖第三方框架，可以和Quarkus、Spring或者Solon框架集成在一起使用。

2. nop-entropy支持GraalVM技术，可以借助于Quarkus 或者SpringNative 框架编译为原生可执行程序，运行时不需要安装JDK，且启动速度提升数十倍。

3. nop-entropy采用云原生设计，内置分布式事务和多租户支持，可以单机运行，也可以作为分布式集群运行，可以提供在线的API服务，也可以将针对单个业务对象的在线服务自动包装为针对批处理文件的批处理任务。对于大多数业务应用场景均提供相应的模型支持，只需少量配置即可完成主要功能，大大降低对手工编码的需求。

4. nop-entropy在开发期可以作为支持增量式开发的低代码平台，自动生成各类代码以及相关文档，在运行期可以作为面向最终用户的无代码平台的支撑技术，允许客户在线调整业务模块功能，以所见即所得的方式进行产品迭代。

5. Nop平台为DSL的设计和研发提供了完整的理论支撑和底层工具集，可以极大简化AIGC与业务领域的结合。可以利用Nop平台的XDef元模型和XDSL领域语言迅速的集成AI大模型。

6. Nop平台自身就是使用Nop平台所开发的，它有约一半的代码由工具自动生成。内部实现也大量使用了Nop平台内置的元编程和Delta合并运算能力。

Nop平台所有部分都会完全开源，不会发布商业化版本。目前已经发布的部分主要包含XLang语言的实现，以及ORM、依赖注入容器(IoC)、分布式配置（Config）、GraphQLEngine、报表引擎（Report Engine）、任务调度引擎(Job Scheduler)、批处理引擎（Batch Prcessing Engine）、规则引擎（Rule Engine）等基础框架， 后续规划包括工作流引擎（Workflow Engine）、商业智能（BI）、流处理引擎等业务开发常用部分。

这些框架并不是对现有开源软件的简单复刻，而是根据可逆计算理论的要求从零开始设计、编写，包含了大量原创设计。Nop平台在代码量减少一个数量级的情况下（不到15万行手写Java代码）实现了比开源框架更多的功能特性，并达到了前所未有的内在一致性、灵活性和可扩展性。

> X = A + B + C
> 
> Y = A + B + D = X + (-C + D) = X + Delta

对于一个满足可逆计算原理的系统X，在不拆解X的情况下，我们总可以补充额外的Delta信息，将它转换为任意的目标Y。因此，在不修改Nop平台源码的情况下，我们总可以通过补充Delta描述实现对平台所有功能的定制修改，比如定制数据库表结构、业务逻辑、可视化设计器等。基于Nop平台开发的所有业务产品也自动继承了这种Delta定制的能力，它可以极大降低大型业务软件的定制化开发难度。

## Nop的亮点优势

Nop平台为AI时代的软件智能制造提供了新的技术架构支撑，它是唯一的在理论层面解决粗粒度软件复用问题的开源平台，可以实现大型银行核心应用在不同客户处进行深度二次开发时无需修改基础产品源码。
Nop平台为实现底层框架、引擎等也提供了新的思路。传统上每个引擎如(Hibernate ORM引擎和Flowable流程引擎等)都是单独设计并实现的，它们最多只会共享少量commons包。而Nop平台将每个引擎都看作是一个模型，将模型结构明确通过元模型定义出来，保存到文本文件中就成为DSL，借助于Nop平台底层的基础设施，可以快速开发和扩展DSL，因此所有引擎可以共享Nop平台的元模型和元编程能力，只要设计自己特有的运行时执行器即可，不用再考虑可扩展性、灵活性、模型可视化设计等事项，使得引擎实现可以极大瘦身。在Nop平台中，所有引擎基本都只有几千行代码量，远小于开源框架动辄数万行的代码量。

Nop平台的目标并不是成为一个 开箱即用、用户友好，在细节上精细打磨的开发框架，而是探索下一代软件构造原理，提供面向未来的软件架构最佳实践。

## 可逆计算的方法论来源

一直以来，我对于软件领域的大量设计原则和所谓的方法论都持有很深的怀疑态度。为什么会存在这些原则，能否从科学的层面证明它们的有效性？比如，我们总是说要高内聚、低耦合、关注点分离，但是什么是高、什么是低、需要分离到什么样的程度？在研究生阶段我开始研发自己的软件框架，试图将物理学和数学中的思想引入到软件架构领域，并于2007年左右相对完整的提出可逆计算理论，在后续的大量产品研发中也逐步验证了该理论的有效性。

大型软件产品普遍存在着从有序到混乱的发展历程，在物理学中对应于热力学第二定律，也就是所谓的熵增原理：熵度量了系统的混乱程度，所有自然发展的过程必然会自发的向着混乱最大化的方向发展，熵永不减少。若过程可逆，则熵不变，若不可逆，则熵增加。

可逆计算的核心是可逆性，而可逆性之所以重要，不仅仅在于它方便了软件元素的灵活复用，深层次的原因是它体现了我们这个世界本质的运作规律。通过遵循可逆计算原则，我们能够有效的控制软件演进过程中的熵增速度。理想情况下，如果系统能够做到完全可逆，则熵是保持不变的。

现实世界中，熵增是无法逃避的宿命。但是即使无法完全消除熵增，我们仍然可以选择熵增发生的地方，例如将熵增集中在差量Delta中。特定客户的需求总是包含着大量随机的、偶然的因素，把它们纳入系统不可避免的会破坏原先统一均衡的系统结构，如果能够把这些偶然因素集中在一个可抛弃的差量Delta中，则可以保护核心架构不会受到侵蚀。当系统交付给新的客户时，我们不必携带上一个客户的个性化需求，可以始终从一个低熵的状态开始。

[可逆计算理论](https://zhuanlan.zhihu.com/p/64004026)试图为软件构造提供一个更加坚实的理论基础，它明确提出应该将“差量”提升为第一性的概念，将全量看作是差量的一种特例（全量=单位元+全量），围绕差量概念去重建整个领域概念体系。可逆计算将软件看作是处于不断演化过程中的抽象实体，
 在不同的复杂性层次上由不同的运算规则所描述，它所关注的是演化过程中产生的微小差量如何在系统内有序的传播并发生相互作用。
