# Paxos算法讲解

Paxos算法的基本知识，可以参考 [200行代码实现基于paxos的kv存储](https://zhuanlan.zhihu.com/p/275710507), [可靠分布式系统-paxos的直观解释](https://zhuanlan.zhihu.com/p/145044486)

## 为什么要学习Paxos算法？

有人可能会问我的工作没有涉及到分布式系统，有必要学习Paxos算法吗？回答是，只要你的问题中涉及到多个状态空间，多种独立活动的实体，就会遇到类似的问题，解决的方法都可以从Paxos算法中找到答案。

还有人可能会说，现在都是用Raft算法，很少有人使用Paxos了。回答是,Raft算法可以看作是Paxos算法的一个变种，它是在Paxos算法的总体精神下选择了一些特殊的实现策略。

Paxos可以类似于一个高层的接口描述，其中只包含最核心的观念和策略，而Raft是一种具体的实现，补充了更多的实现细节，但是这些细节本质上是可选的，并不是实现分布式共识所必须的。

## 什么是Paxos算法？

Paxos算法的执行过程是什么？

以下是智谱清言AI的回答：

Paxos算法是Leslie Lamport在1990年提出的一种分布式一致性算法，用于解决分布式系统中多个节点之间如何达成一致的问题。Paxos算法的核心思想是通过多个节点之间的相互通信和投票，最终达成一致的结果。

Paxos算法的执行过程可以分为以下三个主要阶段：提案阶段（Prepare阶段）、接受阶段（Accept阶段）和学习阶段。下面详细描述这三个阶段：

### 1. 提案阶段（Prepare阶段）

- **提案准备**：提议者（Proposer）选择一个全局唯一的提案编号n，并向所有的接受者（Acceptor）发送一个Prepare请求，该请求包含提案编号n。
- **承诺与反馈**：接受者（Acceptor）接收到Prepare请求后，如果该提案编号n大于此接受者之前承诺过的所有提案编号，则接受者承诺不再接受编号小于n的任何提案，并将它已经接受过的最高编号的提案（如果有的话）回复给提议者。同时，接受者保存这个提案编号n，以备后续的Accept阶段使用。
  
  ### 2. 接受阶段（Accept阶段）
- **提案发送**：如果提议者从多数的接受者那里得到了响应，它就可以发送一个Accept请求。这个请求包含提案编号n和一个提议的值v。这个值v通常是提议者从接受者的响应中选取的最高编号提案的值，如果没有响应包含提案值，提议者可以自由选择一个值。
- **接受提案**：接受者收到Accept请求后，如果该请求的提案编号等于或大于接受者之前承诺的提案编号，则接受者接受这个提案，并将该提案编号和值记录下来。如果请求的提案编号小于接受者之前承诺的提案编号，则接受者忽略这个请求。
  
  ### 3. 学习阶段
- **学习提案**：一旦提议者从多数接受者那里得到接受响应，它就知道这个提案被接受了。此时，提议者将这个提案的值传播给所有的学习者（Learner）。
- **达成共识**：学习者从提议者或接受者那里学习到被接受的提案值，并更新自己的状态。当学习者从多数接受者那里学习到相同的提案值时，系统就达成了共识。
  
  ### 注意事项
- **提案编号的唯一性**：为了保证算法的正确性，提案编号必须是全局唯一的。通常，可以通过组合提议者的唯一标识和该提议者生成的序列号来实现。
- **活性问题**：Paxos算法需要解决活性问题，即保证算法最终能够收敛到一个值。这可能涉及到处理网络延迟、节点故障、提案冲突等问题。
  Paxos算法通过这种多轮的消息交换和投票，保证了分布式系统中的节点最终能够就某个值达成一致，即使是在网络不可靠和节点可能故障的情况下。这个过程虽然复杂，但它是理解和实现分布式系统一致性的关键。
  ===== 智谱清言AI创作完毕====

## Paxos算法的变体

Paxos算法是解决分布式系统中一致性问题的经典算法，由Leslie Lamport在1990年提出。随着时间的推移，Paxos算法衍生出了一些变体，这些变体旨在提高算法的性能、简化理解、增强可用性或适应特定的应用场景。以下是一些Paxos算法的变体：

1. **Multi-Paxos**:
   - 为了解决Paxos算法在处理连续决策时的效率问题，Multi-Paxos允许对多个实例（或多个值）使用相同的领导者，从而减少了选择领导者的开销。
2. **Fast Paxos**:
   - 是Paxos的一个优化版本，它通过减少一轮通信来加速决策过程，但这需要在某些条件下才能实现。
3. **EPaxos (Efficient Paxos)**:
   - EPaxos通过允许并行处理多个提案来提高性能，它适用于冲突较少的场景。
4. **Generalized Paxos**:
   - 旨在处理更复杂的一致性要求，允许某些操作可以在不同服务器上以不同的顺序执行。
5. **Vertical Paxos**:
   - 专门为支持大型集群设计的Paxos变体，它通过分层结构来提高可扩展性。
6. **Cheap Paxos**:
   - 旨在减少Paxos算法中的存储需求，通过减少必须存储的信息量来实现。
7. **Paxos Made Live**:
   - 是Google实现Paxos算法的一个实践版本，它包含了对算法的工程化改进。
8. **Disk Paxos**:
   - 专为在具有持久性存储的系统中实现Paxos算法而设计，确保了即使在系统崩溃后也能恢复状态。
9. **State Machine Replication with Paxos**:
   - 这不是一个单独的变体，而是一种使用Paxos算法来实现状态机复制的通用方法。
10. **Raft**:
- 虽然不是Paxos的直接变体，但Raft算法受到了Paxos的启发，它旨在提供更易于理解和实现的一致性算法。
  这些变体各有优缺点，它们在设计时都考虑了不同的应用场景和性能要求。在选择适合自己系统的算法时，开发者需要根据具体需求来决定使用哪种变体。

===== 智谱清言AI创作完毕====

值被chosen的定义：
  值被多数（超过半数）的acceptor接受。

组变更：任意两个quorum必须有交集。

Fast Paxos:
  使用rnd=0直接尝试一次phase2写入。
为了防止第一次尝试写入冲突后正确执行，quorum需要`n*3/4`，这样后续paxos读取的时候至少要读取`1/2+`，在这`1/2`多中，已经写入的值仍然是多数派。

$$
[\frac 1 2 ] = (\frac 1 4) + [\frac 1 4]
$$

也就是说，时间可能冲突，但是仍然可以通过数多数派得到已经被选定的值。

## Quorum并不需要是Majority

Quorum的要求是任意两个quorum之间存在交集。比如，要求所有Quorum都包含一个指定元素a，这样也是合法的Quorum，只是不容错。`{{a},{a,b},{a,b,c},{a,c}}`

hierarchical quorum ![](https://pic1.zhimg.com/80/v2-e2a584b6379a039596b303442ad849de_1440w.webp)

$$
Q' = (Q -  \{Q_i\}) \cup  \{\bar Q_i\}
$$

去掉一个quorum，然后再加上它的补集，我们得到的仍然是一个合法的quorum集合。

## EPaxos

记录deps,  mmp3与EPaxos的不同在于它记录所有依赖的instance，包括所有间接依赖的，由此才能保证线性一致性。
