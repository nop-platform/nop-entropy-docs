# 从可逆计算看AI时代的复用

最近伴随着ChatGPT的爆火，有一个论调逐渐兴起：我们应该放弃此前软件工程领域反复强调的复用概念。甚至有人提出"降低软件的复杂度只能从源头下手，复用乃万恶之源"。

在我看来，这只是对传统僵化的复用实践的一种批判。传统上基于组合概念的复用实践确实存在问题：只有相同的东西可以被复用，但是粒度越大就越难找到相同的可复用场景。为了使得复用可以实现，我们需要在预制件中预置各类适配条件、选择性开关等，导致产生不必要的复杂性，而且粘结时存在各种胶水工作。但这些并不是否定复用本身的理由。

首先，复用是绝对需要的。我们需要把已知的逻辑结构和逻辑推导路径固化下来，避免每次都重复表达（这种固化下来的东西本质上就是预制件）。很多人概念中的复用是技术性复用，即用某种程序语言结合某些框架所实现的某种业务逻辑的**固化形式**。但真正最有价值的复用是业务逻辑本身的复用，即业务逻辑已经表达清楚，最后如何转换成可执行代码本身，这一点可以通过代码生成器进行，甚至使用AI工具辅助进行，但是他们处理的都是逻辑的实现层面，而业务逻辑本身应该是以无歧义、可分析的形式被复用。当底层技术升级后，完全可以根据业务逻辑层的描述来重新生成。

已知的逻辑结构和逻辑推导路径完全可以用技术中立的形式得以表达，即业务逻辑的表达形式本身也可以被复用，我们复用的是结构规律本身，而不是某种固化的成品。只要结构规律没有发生变化，那么底层的生成推导过程和工具就可以保持不变。 在可逆计算理论中，我们通过DSL来表达业务逻辑，同时通过一系列支撑工具来简化DSL的定义、开发、调试过程。

传统上的复用是僵化的、固化的，即信息被绑定在一定的技术表达形式中。但是如果信息表达满足可逆计算原理，可以反向抽取并可逆转换到其他形式，则复用本身是一件很自然直观的事情：**我们并不需要复用此前的形式，我们所需要复用的是信息本身**。

生成式编程如果要能够长期演化，必然需要明确定义差量概念。Phodal在["未来可期的AI编程"](https://zhuanlan.zhihu.com/p/614319672)一文中写道：

> 生成式 AI可能还意味着：新生成的代码和原来的完全不一样，诸如于行数位置等等。而为了能再次生成，我们还需要记录新的变更到原来的 prompt。所以，在这个时候，如何更好地管理原始需求，变成了一个新的挑战。

这个问题的解决本质上依赖于差量空间和差量合并规律的定义，而这在可逆计算理论中已经提供了系统化的解决方案。

客观规律是不以人的意志为转移的，这句话实际上是说无论人是否意识到，客观规律都是存在的。AI如果需要去解决问题，它也必须意识到并掌握相应的客观规律。如果AI没有掌握加法的规律，那么1到1000之间的加法可以轻松搞定，1到1千亿的加法它就错漏百出了。可逆计算理论本质上只是指出了软件构造的一种结构规律

```
  App = Delta x-extends Generator<DSL>
```

随着智能化的进一步发展，我们必然会观察到DSL、Delta、可逆、Generator这些概念被更加频繁的提起。而DSL和Generator自身的差量化也必然会进入开发者的视野。

可逆计算理论的参考实现Nop平台已开源：

- gitee: [https://gitee.com/canonical-entropy/nop-entropy](https://gitee.com/canonical-entropy/nop-entropy)
- github: [https://github.com/entropy-cloud/nop-entropy](https://github.com/entropy-cloud/nop-entropy)
- 开发示例：[tutorial.md](https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/tutorial/tutorial.md)
- [介绍和答疑视频](https://www.bilibili.com/video/BV1u84y1w7kX/)
