# 关于Nop平台以及低代码平台建设经验的讨论

前些天可逆计算与Nop平台微信群组织了一次讨论，探讨了如何利用差量运算和元编程的概念来解决低代码平台建设中存在的普遍性困难。

## Nop平台的设计目标和开发计划

Nop平台的设计目标不是提供一个功能完善、面向最终用户的低代码产品，而是提供一个基于创新的设计理论重构整个技术栈，为粗粒度、系统级的软件复用铺平道路的技术底座。如果你希望与世界上最优秀的低代码产品如 Mendix、OutSystems等进行竞争，并提供一些超越它们的功能特性，可以参考、借鉴Nop平台中的具体技术方案。

Nop平台目前的有效代码量（除去自动生成的代码和括号）大概10几万行，预计最终代码量在20多万行左右。目前已经完成了支持可逆计算原理的程序语言XLang，以及ORM/IoC/RPC/GraphQL/Rule/Report等基本引擎的实现，年底前预计完成Workflow引擎，明年上半年实现分布式批处理引擎。

Nop平台主要是后端的实现，前端目前使用了百度AMIS框架，原则上可以更换为任何其他低代码前端。因为Nop平台专注于后端，所以欢迎前端框架的同学参与共建，对齐技术接口，减少重复建设。

**Nop平台的开发会持续进行，对中小企业允许免费商用，未来所有功能也都会开源，不会出现收费组件**。第三方可以自行在Nop平台基础上进行优化封装，提供商业化改进和支持，Nop平台的版权协议不会限制这些行为，也不要求二次封装的工作进行开源。**允许二次开发修改包名，但是不允许删除源码头部的版权声明和作者链接**。

## Nop平台如何克服低代码平台普遍存在的技术困难？

## 1. 扩展字段按照纵表形式存储，能不能支持查询和排序？性能比较低怎么办？

NopORM引擎提供了通用的横纵变换机制，它不仅仅可以用于保存扩展字段，而是适用于一切主子表结构，支持查询和排序。具体做法如下：

1. 在子表中定义唯一标识属性keyProp，例如keyProp="fieldName"
2. EQL对象查询语法（类似于JPA中的对象查询语法）访问子表集合中的元素时可以使用对象属性语法，会自动翻译为表关联条件

```
   entity.subEntities.my.status 对应于  entity.getSubEntities().getByKey("my").getStatus()
```

3. 通过alias机制可以将复杂的属性路径映射为简单属性名。在程序中使用时与表上原生的属性没有任何差别。

```
  entity.myStatus ==>  entity.subEntities.my.status
```

扩展字段很多性能受影响时，可以通过配置为每一个表指定对应的扩展字段表，甚至可以为每个表的每个扩展字段指定一个单独的存储表。通过alias和keyProp机制对外统一暴露为普通属性，不会影响应用层编程。

具体介绍可以参见 [低代码平台需要什么样的ORM引擎](https://zhuanlan.zhihu.com/p/543252423)

## 2. SAAS产品的同一个基础功能针对不同的客户会有不同的定制调整，同时基础产品还在不断迭代更新，这两者之间的冲突如何解决？

这里存在两个变换的方向：产品自然发展的方向和定制版本方向，这两种变化如果直接相撞，必然会出现激烈的冲突。Nop平台提供了如下解决方案：

1. Delta差量合并：相比于Git版本管理，可以避免大量非业务层面的冲突问题。
   Git相当于是采用文本行差量空间，一些业务上完全等价的操作（如方法的前后顺序并不影响语义，再比如格式化代码）会造成文本行空间中的剧烈变化。同一行上DSL不同的属性的变化一般也是不冲突的，
   但是git层面会识别为行修改。
   同时，Delta合并会明确表明覆盖方向，比如x:override="remove"，x:override="append"，避免了语义不清导致的冲突
2. 在基础产品层和业务应用层之间允许插入任意多的Delta层，例如产品Bug修正层和产品改进层，在Bug修正层中紧急修复一些等不及产品层修复并下发补丁的bug，而在产品改进层可以增加一些可以同步回基础产品的特性功能，不用将通用的功能和针对当前业务进行的定制修改纠缠在一起。
